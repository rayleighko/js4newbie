# 자료구조 기초

## 들어가기 전에

우리는 과거와 현재를 포함해 미래에도 Computer Science(이하 CS)를 공부하면서 필연적으로 만나게 되는 영역이 있습니다. 그것들은 'CS 기초'라고 불리며, 컴퓨터 공학 분야에서 일하는 엔지니어들에게 가장 중요한 영역으로 생각되고 있습니다.

> 기초라고 해서 쉽다는 것이 아닙니다. 기초는 말 그대로 학문의 뼈대를 이루고, 심화적인 내용이나 현대의 트랜드를 이해하기 위해 필수적으로 알고 있어야 하는 내용을 말합니다. 더불어 기초가 부족하다는 것은 하나의 '부채' 혹은 '빚'으로 작용해 미래에 좋지 않은 영향을 끼치게 됩니다.
>
> 이를 극복하기 위해 여기서 언급하는 모든 기초를 학습할 필요가 있습니다. 물론 당장의 업무를 처리하기 위해 기초를 후순위로 미루는 것을 이해할 수는 있지만, 결코 바랍직하지 않은 방법입니다.

CS 기초는 대표적으로 다음의 내용을 포함하고 있습니다.

* Data structure, 자료구조
* Algorithm, 알고리즘
* Computer network, 컴퓨터 네트워크
* Computer architecture , 컴퓨터 구조
* Operating system, 운영체제
* Database, 데이터베이스
* ...

위에서 언급한 기초들은 Web, Game, Graphics 등 다양한 분야에서 공통적으로 통용되는 영역입니다. 각 영역의 중요도는 업무의 형태에 따라 다르겠지만, 보편적으로 모든 내용을 학습해야 합니다.

> 위의 내용을 커리큘럼으로 배운 전공자가 아닌 컴퓨터를 처음 접하는 사람이 모든 영역을 학습하고 실무에 진입하는 것은 불가능에 가깝습니다. 대부분의 회사에서도 위의 내용을 검증하려 노력하지만, 절대적인 평가보다는 상대적인 평가를 위주로 인재를 판단합니다. 따라서 당장 모든 내용을 학습할 필요는 없지만, 필연적으로 학습해야 함에는 틀림이 없기 때문에 각 영역에 대한 지속적인 학습이 권장됩니다.

## 자료구조란

여기서 우리는 기초 중에서 자료구조를 학습하게 됩니다. 자료구조는 하나 이상의 데이터를 구성하기 위한 구조를 나타내며, 그 종류는 다양하지만 대표적으로 다음의 6가지가 존재합니다.

* Array, 배열
* List, 리스트
* Queue, 큐
* Stack, 스택
* Graph, 그래프
* Tree, 트리

보편적으로 이 6가지만 이해하면 자료구조의 기초를 학습했다고 할 수 있습니다. 우리는 이 자료를 통해 6가지의 자료 구조를 학습해보고 어떤 순간에 사용되는지 살펴보도록 하겠습니다.

> 보편적으로 6가지로 대표되지만, 본질적으로 따지고 보면 배열과 리스트를 이용해 구현하는 자료 구조의 집합이라고 이해할 수도 있습니다. 그 이유는 큐와 스택, 그래프, 트리는 배열을 통해 구현될 수도, 리스트를 통해 구현될 수도 있기 때문입니다.
>
> 경우에 따라 Set, Hash, HashMap, HasjTable 등을 포함시킬 수도 있지만, 보편적인 관점에서의 기초를 학습할 예정이기 때문에 이 자료에서는 키워드만 언급하고 넘어가도록 하겠습니다.

추가적으로 이 글에서는 자료구조의 기초를 포함하고 있지만, 자료구조의 모든 내용을 포함하고 있지 않습니다. 따라서 이 글을 시작으로 자료구조를 깊게 공부하시길 바라겠습니다.

### 선형 구조와 비선형 구조

일반적으로 자료구조를 구분할 때 선형과 비선형 구조로 구분하기도 합니다. 각각 선의 형태를 띄는 것과 그렇지 않은 것으로 풀어 말할 수 있으며, 선형 구조는 배열, 리스트, 큐, 스택을 말하고 비선형 구조는 그래프와 트리를 말합니다.

> 그 이유는 글이 진행되면서 서서히 해결되기 때문에 당장은 각각을 구분하는 기준이 존재한다는 것을 이해하고 넘어가도록 합시다.

### 자료구조가 중요한 이유

자료구조는 적은 수의 데이터를 관리하기 위해 고안된 것이 아닙니다. 가령 1개의 데이터를 처리하는데 1초가 걸리는 크기 1의 구조가 있다고 하면, 이 구조를 이용해 1000개의 데이터를 처리하려면 1000의 크기와 1000초가 필요하게 됩니다.
이때 자료구조는 1개의 데이터를 처리하는 시간과 크기를 줄여 데이터를 처리하는데 더 적은 크기와 더 적은 시간이 필요하게끔 하는 역할을 합니다.

따라서 자료구조가 중요한 이유는 프로그램 내에서 자료를 가장 효율적으로 처리하기 위함이고, 그것을 통해 보다 성능 좋은 프로그램을 만들기 위함입니다.

### 논리적으로 생각하기

자료구조는 논리적인 형태를 말합니다. 그 의미는 구현자의 의도에 따라 그 형태가 변한다는 것입니다. 모든 데이터의 형태는 논리적인 구조이며, 구현자가 직접 구현하고 해당 자료구조의 형태로 동작하게 만들어야 합니다. 가령 javascript를 이용해 Queue의 동작을 따라하는 Array를 구현했다면 이는 Queue라고 할 수 있습니다.

이는 자율적인 동시에 위헙하기도 합니다. 구현자의 의도와 명확하게 부합하는 자료구조를 만들어야 하기 때문입니다.

## Array, 배열

개발을 하다보면 가장 쉽게 만날 수 있는 배열입니다. 대부분의 언어에서 그 형태를 제공하기 때문에 다음과 같은 선언만으로 구현할 수 있습니다.

```text
// code-1

['사과', '바나나'];

```

위의 내용은 '사과'라는 문자와 '바나나'라는 문자를 저장하고 있는 크기 2의 fruits이라는 문자열 배열을 말합니다. 이처럼 하나의 배열은 특정한 데이터의 집합을 의미합니다. 여기서 문자열 배열이라고 말한 이유는 문자열을 저장하고 있는 배열이기 때문입니다.

더불어 각각의 문자열에는 '인덱스(index)'라는 개념이 존재합니다. 이때의 인덱스는 0부터 시작해 각 데이터의 위치를 나타내며, 다음과 같이 사용됩니다.

```text

fruits = ['사과', '바나나', '멜론', '파인애플', '포도'];

fruits[0];
// '사과'
```

> index가 0부터 시작하는 이유는 중요합니다. 결론적으로 보면 모든 데이터가 0부터 시작하기 때문인데, 자료구조가 중요한 이유처럼 데이터를 최대한 효율적으로 사용하기 위해 고안된 구조입니다. 현대에 이르러서는 이정도 차이는 크게 중요하지 않기 때문에 0이 아닌 1부터 시작하는 구조가 등장하기도 하지만, 과거부터 전해져오는 하나의 관례로 통용되게 되었습니다.
>
> Javascript의 배열은 리스트 형태로 제공됩니다. 따라서 Javascript의 배열을 사용할 때는 배열이 아닌 List의 특징을 아는 것이 중요합니다. 또한, Javascript와 같이 Array 형태의 List를 Array라고 이야기하며, 배열과의 차이는 '데이터에 대한 인덱스 종속 여부'라는 것을 기억하세요.

배열은 보편적으로 동일한 형태의 여러 데이터를 저장하기 위해 사용합니다. 가령 code-2의 코드 대신 code-3의 코드를 사용합니다.

```text
// code-2

apple = '사과';
banana = '바나나';
melon = '멜론';
pineapple = '파인애플';
grape = '포도';

```

대신

```text
// code-3

fruits = ['사과', '바나나', '멜론', '파인애플', '포도'];

```

을 사용합니다.

### 배열의 한계

배열은 분명한 한계가 존재합니다. 한 번 고정적으로 선언된 배열은 한 번 선언되면 그 크기를 변경하기 어렵습니다. 따라서 배열은 정해진 크기의 데이터를 저장할 때 사용하면 좋습니다.

> 물론 Javascript 등의 언어에서는 배열의 크기를 변경하는 것은 어렵지 않을 수 있습니다. 다만, 일반적인 관점에서 배열을 관리할 때는 크기를 변경하는 것은 까다롭기 때문에 배열은 크기가 정해진 구조에서 사용할 것을 권장합니다.

더불어 배열은 다수의 데이터를 그룹핑해서 효율적으로 관리하고, 각각을 인덱스로 구분합니다. 따라서 인덱스를 알고 있다고면, 해당 자료를 찾기 쉽다는 장점이 있습니다. 다만, 인덱스를 이용해 데이터를 가져오기 위해서는 인덱스가 데이터에 종속적으로 연결되어 있어야 하는데, 이는 한 데이터가 삭제되면 해당 인덱스를 비워둬야 한다는 단점을 갖기도 합니다.

![array-io](https://s3.ap-northeast-2.amazonaws.com/opentutorials-user-file/module/1335/2879.png)

위의 형태는 3번째 인덱스에 존재했던 40이라는 데이터를 삭제한 형태입니다. 배열의 경우는 위와 같이 40이라는 데이터를 삭제하면 해당 자리를 비워두게 됩니다.

## List, 리스트

리스트는 배열과 달리 인덱스가 데이터에 종속적이지 않습니다. 리스트는 배열이 갖는 인덱스 구조의 장점을 버린 대신 각 데이터의 빈틈을 없애는 방법을 선택했습니다. 따라서 리스트는 데이터의 삽입과 삭제에 대한 데이터 낭비가 줄고 검색 시간이 길어졌다는 특징을 가지고 있습니다. 가령 배열의 한계에서 언급한 것처럼 '40'이라는 데이터의 삭제가 일어나면 다음과 같이 40의 자리를 50이 채우게 됩니다.

![list-io1](https://s3.ap-northeast-2.amazonaws.com/opentutorials-user-file/module/1335/2880.png)

이처럼 리스트는 Array와 유사하지만, 인덱스가 데이터에 종속적이지 않습니다. 데이터를 추가하는 것도 마찬가지입니다. 리스트에서는 다음과 같은 데이터가 있다고 할 때,

![list-io2](https://s3.ap-northeast-2.amazonaws.com/opentutorials-user-file/module/1335/2881.png)

50이라는 데이터를 추가하면 다음과 같은 형태가 됩니다.

![list-io3](https://s3.ap-northeast-2.amazonaws.com/opentutorials-user-file/module/1335/2883.png)

따라서 일반적으로 리스트를 부를 때 순서가 있는 데이터의 모임이라고 이야기합니다. 이때 빈 데이터 껍데기는 허용하지 않기 때문에 리스트를 사용할 때 유의해야 합니다.

> 추가적으로 Set이라는 데이터와 비교할 때 배열과 리스트는 중복을 허용하지만 Set은 중복을 허용하지 않는다는 특징이 있습니다.

리스트에는 Array List와 Linked List가 존재합니다. 둘의 가장 큰 차이는 '데이터의 연결 구조'입니다. Array List는 배열을 이용해 Javascript의 배열 구조처럼 리스트를 구현한 것을 말합니다.

```javascript
const fruits = ['사과', '바나나']
```

Array List는 내부적으로 배열을 사용하기 때문에 인덱스를 이용해 데이터에 접근하는 것이 가능합니다. 따라서 데이터를 조회하는 속도가 빠릅니다. 하지만, 데이터를 추가하거나 삭제하게 되면 각 순서가 일정하게 변경되어야 하기 때문에(중간의 데이터가 한 칸 이동하면 다른 데이터들도 이동이 필요하기 때문) 데이터의 삽입과 삭제에 상대적으로 오랜 시간이 소요됩니다.

반면 Linked List는 배열을 사용하지 않고, 하나의 데이터에 다음 엘리먼트의 위치 정보를 포함하게 됩니다. 이런 구조는 특정 데이터를 조회하는 인덱스가 존재하지 않기 때문에 조회하는 속도가 느립니다. 하지만, 데이터를 추가하거나 삭제할 때 다른 데이터에 영향을 주지 않기 때문에 상대적으로 빠른 시간 내에 데이터의 삽입/삭제를 진행합니다.

두 List 구조는 각각 장단점을 가지고 있습니다. 따라서 구현자에 의해 적재적소에 사용하는 것이 바람직합니다. 일반적으로 고정된 데이터의 검색이 필요한 경우에는 Array List가, 검색이 필요없는 가변적인 데이터가 필요한 경우에는 Linked List를 사용합니다.

## Queue, 큐

큐는 선입선출(FIFO, First In First Out)으로 데이터가 쌓이며, 데이터를 삽입하는 enqueue과 데이터를 추출하는 dequeue라는 키워드로 데이터를 관리합니다.

일반적인 큐는 선형이지만, 크기가 제한되어 있고 빈 공간을 사용하려면 모든 자료를 꺼내거나 자료를 한 칸씩 옮겨야 한다는 단점이 있기 때문에 환(동근 고리)형 큐를 구현해 선형 큐의 문제점(배열로 큐를 선언할시 큐의 삭제와 생성이 계속 일어났을때, 마지막 배열에 도달후 실제로는 데이터공간이 남아있지만 오버플로우가 발생)을 보완할 수도 있습니다.

여기서는 기본적인 선형 큐만 살펴보도록 하겠습니다. 선형 큐는 다음과 같은 모양을 가집니다.

![queue-io](https://cdn.programiz.com/sites/tutorial2program/files/queue.jpg)

앞서 말한 것처럼 선입선출의 구조로, 먼저 들어온 데이터가 먼저 빠져나가는 것을 볼 수 있습니다. 

### 큐는 일상에서

일상에서는 '줄 서기', '편의점의 음료수 배치' 등을 떠올릴 수 있습니다.

큐는 보편적으로 순서대로 처리해야 하는 작업을 임시로 저장해두는 버퍼(Buffer)로서 사용됩니다. 그래서 대부분의 Buffer 타입이 큐의 형태를 가지고 있습니다.

## Stack, 스택

스택은 다음과 같은 이미지를 상상하시면 됩니다.

![stack-intro](https://cdn.programiz.com/sites/tutorial2program/files/stack-of-plates_0.jpg)

흔히 스택을 쌓는다고 이야기하는 것처럼 스택은 하나의 바구니에 데이터들이 순차적으로 담겨져있는 형태를 가집니다. 큐와는 다르게 선입후출(FILO, First In Last Out) 혹은 후입선출(LIFO, Last In First Out)으로 데이터가 쌓이게 됩니다(일반적으로 후입선출이라고 부릅니다).

데이터의 삽입에는 push, 삭제에는 pop이라는 용어가 사용되며 다음과 같은 형태로 데이터를 관리하게 됩니다.

![stack-io](https://cdn.programiz.com/sites/tutorial2program/files/stack.jpg)

### 스택은 일상에서

일상에서는 물건을 쌓아 올리는 상황이나 질서있게 스쿨버스를 탄 상황(먼저 탄 순서대로 내리는 경우)을 생각하시면 됩니다. 또한, 웹 브라우저의 '앞으로 가기'와 '뒤로 가기'의 동작이 스택에 해당합니다.

> 참고로 앞으로 살펴볼 트리 구조의 깊이 우선 탐색(Depth First Search: 한 노드의 끝까지 탐색한 후 옆으로 이동하는 방식)에서 사용됩니다.

## Graph, 그래프

상하위 개념이 없는 Node(노드 혹은 버텍스(vertax))와 각 노드 사이의 Edge(엣지 혹은 아크(Arc))의 집합으로 데이터를 이루는 형태를 말합니다. 다음과 같은 모양을 가집니다.

![graph-intro](https://cdn.programiz.com/sites/tutorial2program/files/graph-vertices-edges.jpg)

코드에서는 행렬로 표현되며, code-4과 같은 형태를 가집니다.

```text
// code-4

Node = {0, 1, 2, 3}
Edge = {(0,1), (0,2), (0,3), (1,2)}
Graph = {Node, Edge}

```

따라서 둘을 함께 표현하면 다음과 같이 표현됩니다.

![graph-matrix](https://cdn.programiz.com/sites/tutorial2program/files/graph-adjacency-matrix.jpg)

각 엣지는 벡터와 스칼라로 재현되며, 방향성의 여부에 따라 그래프의 형태가 달라지게 됩니다. 스칼라 엣지로 구현된 그래프는 무방향성(Undirected) 그래프, 벡터 엣지로 구현된 그래프는 방향성(Directed) 그래프라고 이야기하며 각각 다음과 같은 형태를 가집니다.

### 방향성(Directed) 그래프

![directed-graph](https://kr.mathworks.com/help/matlab/math/simpledirectedgraph_ko_KR.png)

### 무방향성(Undirected) 그래프

![undirected-graph](https://kr.mathworks.com/help/matlab/math/simpleundirectedgraph_ko_KR.png)

앞서 잠깐 이야기한 것처럼 그래프틑 비선형적 구조를 가지며, 관계를 표현하는 데이터에서 주로 사용됩니다.

### 그래프는 일상에서

일상에서는 지하철의 노선도에서 사용됩니다. 일반적으로 매칭 알고리즘이나 추천 알고리즘에서 사용되기도 합니다.

## Tree, 트리

### 참고자료

[opentutorials 자료 구조](https://opentutorials.org/module/1335/8636)
[programiz의 stack](https://www.programiz.com/dsa/stack)
[programiz의 queue](https://www.programiz.com/dsa/queue)
[programiz의 graph](https://www.programiz.com/dsa/graph)
[programiz의 tree](https://www.programiz.com/dsa/tree)